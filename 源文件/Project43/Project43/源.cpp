#include <stdio.h>                    /*寻找多数元素（主元素）问题*/
#include <stdlib.h>                   /*此代码为最简代码（时间复杂度最简）*/


int a[101], n;                        /*规定多少个数，存数*/



/*寻找候选者算法*/                           
/*归纳法分析此问题
在原序列中去除两个不同的元素后，那么在原序列中出现次数超过了50%的数，在新序列中的出现次数也一定会超过50%。
例1：

1，2，2，3，2，2，3  显然2是多数元素
去除1，2，在2，3，2，2，3中2仍是多数元素
去除1，3，在2，3，2，2，3中2更是多数元素

例2：

1，3，2，3，2，2，3  显然没有多数元素
去除1，3，在2，3，2，2，3中2成了多数

故产生了一个新问题，在最终序列遍历完后找到的多数元素不一定是多数元素，但如果序列有多数元素存在，
则在最终序列遍历完后找到的多数元素一定为该序列的多数元素，故我们需要一个函数来找序列中是否有多数元素*/

/*找出多数元素*/
int Candidate(int m)
{
	int c=a[m]; //将新序列第一个数开始向后遍历
	int count = 1;//定义计数器
	int j;
	for ( j= m + 1; count > 0 && j < n; ++j)   //如果不相等的数等于了相等的数，去除该段已遍历的序列
	{
		if (a[j] == c)//如果与第一个数相等，计数器加1
		{
			count++;
		}
		else
		{
			count--;//不相等减1
		}
	}
	if (j == n)           //序列遍历完
	{
		return c;
	}
	else                 //如没有，则从接下来新的数开始再往后遍历
	{
		return Candidate(j);
	}
}


/*判断是否有多数元素*/
int Majority()
{
	int c = Candidate(1);
	int i, count = 0;
	for (i = 1; i <= n; ++i)
	{
		if (a[i] == c)
		{
			count++;
		}
	}
	if (count > n / 2)          //如超过一半，则存在这个数
	{
		return c;           
	}
	else
	{
		return 0;
	}
}



int main(void)
{
	printf("数据个数:\n");
	scanf_s("%d",&n);
	int i;
	for (i = 1; i <= n; ++i)
	{
		scanf_s("%d",&a[i]);
	}
	if (i = Majority() != 0)
	{
		printf("%d", i);
	}
	else
	{
		printf("不存在多数元素\n");
	}
	return 0;
}